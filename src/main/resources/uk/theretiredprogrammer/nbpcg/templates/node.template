<#--
    Copyright 2015-2017 Richard Linsdale.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

 -->
<#if license = "apache20" >
/*
 * Copyright ${copyright}.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
</#if>
<#if license = "gpl30" >
/*
 * Copyright (C) ${copyright}
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
</#if>
<#if license = "lgpl21" >
/*
 * Copyright (C) ${copyright}.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */
</#if>
<#-- Freemarker Template for ChildFactory class plus an inner classes for Nodes. -->
<#assign templateauthor = "Richard Linsdale (richard at theretiredprogrammer.uk)" />
<#assign ENTITYINFO = entityinfo[useentityinfo] >
<#if type = "Icon" >
<#assign type2 = "Icon" />
<#else>
<#assign type2 = "Tree" />
</#if>
package ${package};

import java.awt.datatransfer.DataFlavor;
import java.io.IOException;
import java.text.MessageFormat;
import java.text.ParseException;
import java.util.List;
import javax.swing.Action;
import ${datapackage}.*;
<#if ENTITYINFO.customchildfactorypackage?? >
import ${ENTITYINFO.customchildfactorypackage}.${ENTITYINFO.name}${type}NodeChildFactory;
</#if>
import uk.theretiredprogrammer.nbpcglibrary.annotations.UseCommonNodeAction;
import uk.theretiredprogrammer.nbpcglibrary.annotations.UseCommonNodeActions;
import uk.theretiredprogrammer.nbpcglibrary.data.entity.*;
import uk.theretiredprogrammer.nbpcglibrary.node.nodes.*;
import uk.theretiredprogrammer.nbpcglibrary.node.properties.*;
import uk.theretiredprogrammer.nbpcglibrary.api.LogicException;
import org.openide.nodes.PropertySupport;
import ${datapackage}.${ENTITYINFO.name}.${ENTITYINFO.name}Field;
import uk.theretiredprogrammer.nbpcglibrary.common.StringX;
<#list ENTITYINFO.child![] as c>
<#if (type = "Icon" && c.hasiconview = "yes" ) || (type = "") >
import static ${package}.${c.name?cap_first}${type}Node.${c.name?upper_case}${type?upper_case}NODE_FLAVOR;
<#if type != "Icon" && c.copymoveentity??>
<#assign COPYMOVEENTITYINFO = entityinfo[c.copymoveentity] >
import static ${package}.${COPYMOVEENTITYINFO.name}${type}Node.${COPYMOVEENTITYINFO.name?upper_case}${type?cap_first}NODE_FLAVOR;
</#if>
</#if>
</#list>

/**
 * Node for ${ENTITYINFO.name}${type}Node.
 *
 * (Class generated by NetBeans Platform Code Generator tools using ${DEFINITION_FILE}.  
 * Do not edit this file.  Apply any changes to the definition file and regenerate all files.)
 *
 * @author ${templateauthor}
 */
public class ${ENTITYINFO.name}${type}Node extends ${type2}Node<${ENTITYINFO.name}Entity, ${ENTITYINFO.name}, ${ENTITYINFO.parentname},${ENTITYINFO.name}Field> {

    /**
    * Data Flavor for Nodes of type ${ENTITYINFO.name}${type}Node
    */
    public static final DataFlavor ${ENTITYINFO.name?upper_case}${type?upper_case}NODE_FLAVOR = new DataFlavor(${ENTITYINFO.name}${type}Node.class, "${ENTITYINFO.name}${type}Node");

<#assign haschildren = false>
<#list ENTITYINFO.child![] as c>
<#assign haschildren = true >
</#list>
<#if ENTITYINFO.customchildfactorypackage?? >
<#assign haschildren = true >
</#if>
<#if haschildren >

        private final ${ENTITYINFO.name}${type}NodeChildFactory cf;

        /**
         * Constructor
         *
         * @param e the entity associated with this node
         */
        public ${ENTITYINFO.name}${type}Node(${ENTITYINFO.name} e) {
            this(e, new ${ENTITYINFO.name}${type}NodeChildFactory(e));
        }

        private ${ENTITYINFO.name}${type}Node(${ENTITYINFO.name} e, ${ENTITYINFO.name}${type}NodeChildFactory cf) {
            super((be) -> new ${ENTITYINFO.name}(be), e, cf, ${ENTITYINFO.name}Rest.class,
                new DataFlavor[] {
<#list ENTITYINFO.child![] as c>
<#if (type = "Icon" && c.hasiconview = "yes" ) || (type = "") >
                    ${c.name?upper_case}${type?upper_case}NODE_FLAVOR,
<#if type != "Icon" && c.copymoveentity??>
<#assign COPYMOVEENTITYINFO = entityinfo[c.copymoveentity] >
                    ${COPYMOVEENTITYINFO.name?upper_case}${type?upper_case}NODE_FLAVOR,
</#if>
</#if>
</#list>
                    }
<#if ENTITYINFO.nomodifiers?? || type == "Icon" >
                 ,"${ENTITYINFO.icon}", 0 );
<#else>
                 ,"${ENTITYINFO.icon}", CAN_COPY | CAN_DELETE | CAN_CUT);
</#if>
            this.cf = cf;
        }
<#else>
   
        /**
         * Constructor
         *
         * @param e the entity associated with this node
         */
        public ${ENTITYINFO.name}${type}Node(${ENTITYINFO.name} e) {
            super((be) -> new ${ENTITYINFO.name}(be), e, ${ENTITYINFO.name}Rest.class
<#if ENTITYINFO.nomodifiers?? || type == "Icon">
                    ,"${ENTITYINFO.icon}", 0 );
<#else>
                    ,"${ENTITYINFO.icon}", CAN_COPY | CAN_DELETE | CAN_CUT);
</#if>
        }
</#if>

<#if type != "Icon" >
    @UseCommonNodeActions({
<#if !(ENTITYINFO.nomodifiers??)>
<#if ENTITYINFO.orderable = "yes">
            @UseCommonNodeAction(id = "uk.theretiredprogrammer.nbpcglibrary.node.actions.NodeReorderAction",
                    node = "${ENTITYINFO.name}Node", position = 810),
</#if>
<#if haschildren >
            @UseCommonNodeAction(id = "uk.theretiredprogrammer.nbpcglibrary.node.actions.NodePasteAction",
                    node = "${ENTITYINFO.name}Node", position = 830),
</#if>
            @UseCommonNodeAction(id = "uk.theretiredprogrammer.nbpcglibrary.node.actions.NodeCutAction",
                    node = "${ENTITYINFO.name}Node",
                    position = 850, separator = 800),
            @UseCommonNodeAction(id = "uk.theretiredprogrammer.nbpcglibrary.node.actions.NodeCopyAction",
                    node = "${ENTITYINFO.name}Node", position = 870),
            @UseCommonNodeAction(id = "uk.theretiredprogrammer.nbpcglibrary.node.actions.NodeDeleteAction",
                    node = "${ENTITYINFO.name}Node", position = 890),
<#if ENTITYINFO.orderable = "yes" >
            @UseCommonNodeAction(id = "uk.theretiredprogrammer.nbpcglibrary.node.actions.NodeMoveUpAction",
                    node = "${ENTITYINFO.name}Node", position = 910),
            @UseCommonNodeAction(id = "uk.theretiredprogrammer.nbpcglibrary.node.actions.NodeMoveDownAction",
                    node = "${ENTITYINFO.name}Node", position = 930),
</#if>
</#if>
        })
    private static void useCommonNodeActions() {} // a dummy method
</#if>
        @Override
        protected DataFlavor nodeGetDataFlavor() {
           return ${ENTITYINFO.name?upper_case}${type?upper_case}NODE_FLAVOR; 
        }

<#list ENTITYINFO.field![] as field>
<#if field.type != "rootref" >
        StringReadonlyProperty ${field.name}property;
</#if>
</#list>

        @Override
        protected List<PropertySupport.ReadOnly<?>> createPropertyItems(List<PropertySupport.ReadOnly<?>> props) {
                props.add(new StringReadonlyProperty("Node Type", "${ENTITYINFO.name}${type}Node"));
<#list ENTITYINFO.field![] as field>
<#if field.type != "rootref" >
<#if field.type == "datetime" >
                try {
</#if>
                props.add(${field.name}property = new StringReadonlyProperty("${field.label}", format${field.name?cap_first}()));
<#if field.type == "datetime" >
                } catch (ParseException ex) { /* ignore prop if it fails to format */ } 
</#if>
</#if>
</#list>
            return props;
        }
        
        @Override
        protected void nodeProcessFieldChange(${ENTITYINFO.name}Field field) {
                if (idproperty != null) {
<#list ENTITYINFO.field![] as field>
<#if field.type != "rootref" >
<#if field.type == "datetime" >
                try {
</#if>
                    ${field.name}property.update(format${field.name?cap_first}());
<#if field.type == "datetime" >
                } catch (ParseException ex) { /* ignore prop if it fails to format */ } 
</#if>
</#if>
</#list>
                    propertyChange();
            } else {
                switch (field) {
<#list ENTITYINFO.field![] as field>
<#if !(field.hidden??) >
<#if field.type = "rootref" >
<#elseif field.type = "idx" >
                    case ${field.name?upper_case}:
                        if (${field.name}property != null) {
                            ${field.name}property.update(format${field.name?cap_first}());
                            propertyChange("${field.label}");
                        }
                        break;
<#else>
                    case ${field.name?upper_case}:
                        if (${field.name}property != null) {
                            ${field.name}property.update(format${field.name?cap_first}());
                            propertyChange("${field.label}");
                        }
                        break;
</#if>
</#if>
</#list>
                }
            }
        }
        
    @Override
    protected void nodeCutPaste(BasicNode child) throws IOException {
        CoreEntity e = child.getEntity();
<#list ENTITYINFO.child![] as child>
        if (e instanceof ${child.name?cap_first}) {
            ${child.name?cap_first} f = (${child.name?cap_first}) e;
            f.getParent().remove${child.name?cap_first}(f);
            getEntity().add${child.name?cap_first}(f);
            return;
        }
</#list>
         addNewChild(e);
    }

    @Override
    protected void nodeCopyPaste(BasicNode child) throws IOException {
        CoreEntity e = child.getEntity();
<#list ENTITYINFO.child![] as child>
        if (e instanceof ${child.name?cap_first}) {
            ${child.name?cap_first} f = new ${child.name?cap_first}(((${child.name?cap_first}) e).getBaseEntity());
            ${ENTITYINFO.name} p = getEntity();
            p.add${child.name?cap_first}(f);
            f.linkToParent(p);
            return;
        }
</#list>
        addNewChild(e);
    }

    private void addNewChild(CoreEntity e){
<#list ENTITYINFO.child![] as c>
<#if c.copymoveentity??>
        if (e instanceof ${c.copymoveentity}) {
            ${c.name?cap_first} f = ${c.name?cap_first}.getEM().getNew(getEntity());
            f.set${c.copymoveentity}((${c.copymoveentity}) e);
            return;
        }
</#if>
</#list>
        throw new LogicException("${ENTITYINFO.name} Entity does not have a child of the requested class (" + e.getClass().getSimpleName() + ")");
    }

    @Override
    protected void nodeDelete() throws IOException {
        getEntity().remove();
    }

    @Override
    protected void nodeReorderChildByFlavor(DataFlavor df, int[] perm) {
<#list ENTITYINFO.child![] as c>
<#if c.orderable = "yes" >
        if (df == ${c.name?upper_case}${type?upper_case}NODE_FLAVOR) {
            getEntity().reorder${c.name?cap_first}s(perm, cf.getOffsetMin${c.name?cap_first}s(), cf.getOffsetMax${c.name?cap_first}s());
            return;
        }
</#if>
</#list>
    }

    @Override
    public Action getPreferredAction() {
        return findDefaultAction("${ENTITYINFO.name}${type}Node");
    }

    @Override
    public Action[] getActions(boolean context) {
        return findActions("${ENTITYINFO.name}${type}Node");
    }

    @Override
    public String getDisplayName() {
<#list ENTITYINFO.displaynameformat as df >
        return MessageFormat.format("${df.format}", <#list df.display as dp>format${dp.field}()<#if dp_has_next>, </#if></#list>);
</#list>
    }

    @Override
    public String getDisplayTitle() {
<#if ENTITYINFO.displaytitleformat??>
<#list ENTITYINFO.displaytitleformat as df>
        return MessageFormat.format("${df.format}", <#list df.display as dp>format${dp.field}()<#if dp_has_next>, </#if></#list>);
</#list>
<#else>
        return getDisplayName();
</#if>
    }

    @Override
    public String getSortKey() {
<#if ENTITYINFO.sortformat?? >
<#list ENTITYINFO.sortformat as df>
        return MessageFormat.format("${df.format}", <#list df.display as dp>format${dp.field}(<#if dp.length??>${dp.length}</#if>)<#if dp_has_next>, </#if></#list>);
</#list>
<#else>
        return getDisplayTitle();
</#if>
    }

<#list ENTITYINFO.field![] as field>
<#if field.type != "rootref" >
<#if field.type="reference" >
    /**
     * Get the formatted text version of ${field.name} field
     *
     * @return the formatted String 
     */
    public String format${field.name?cap_first}() {
        return getEntity().get${field.name?cap_first}()!=null ? get${field.name?cap_first}().getDisplayTitle(): "undefined";
    }
<#elseif field.type="ref" >
    /**
     * Get the formatted text version of ${field.name} field
     *
     * @return the formatted String 
     */
    public String format${field.name?cap_first}() {
        return getParentNode().getDisplayName();
    }
<#elseif field.type="int" >
    /**
     * Get the formatted text version of ${field.name} field
     *
     * @return the formatted String 
     */
    public String format${field.name?cap_first}() {
        return Integer.toString(getEntity().get${field.name?cap_first}());
    }
<#elseif field.type="idx"  >
    /**
     * Get the formatted text version of ${field.name} field
     *
     * @return the formatted String 
     */
    public String format${field.name?cap_first}() {
        return Integer.toString(getEntity().getIdx());
    }
<#elseif field.type="long" >
    /**
     * Get the formatted text version of ${field.name} field
     *
     * @return the formatted String 
     */
    public String format${field.name?cap_first}() {
        return Long.toString(getEntity().get${field.name?cap_first}());
    }
<#elseif field.type="boolean" >
    /**
     * Get the formatted text version of ${field.name} field
     *
     * @return the formatted String 
     */
    public String format${field.name?cap_first}() {
        return getEntity().get${field.name?cap_first}()? "Yes": "No";
    }
<#elseif field.type="date">
    /**
     * Get the formatted text version of ${field.name} field
     *
     * @return the formatted String 
     * @throws java.text.ParseException if problems
     */
    public String format${field.name?cap_first}() throws ParseException {
        return DATEONLY_READABLE.format(getEntity().get${field.name?cap_first}());
    }
<#elseif field.type="datetime" >
    /**
     * Get the formatted text version of ${field.name} field
     *
     * @return the formatted String
     * @throws java.text.ParseException if problems 
     */
    public String format${field.name?cap_first}() throws ParseException {
        return DATETIME_READABLE.format(getEntity().get${field.name?cap_first}());
    }
<#elseif field.type="currency" || field.type="decimal" >
    /**
     * Get the formatted text version of ${field.name} field
     *
     * @return the formatted String 
     */
    public String format${field.name?cap_first}() {
        return getEntity().get${field.name?cap_first}().toPlainString();
    }
<#elseif field.type="String" ||  field.type="enum" || field.type="password" >
    /**
     * Get the formatted text version of ${field.name} field
     *
     * @return the formatted String 
     */
    public String format${field.name?cap_first}() {
        return getEntity().get${field.name?cap_first}();
    }
</#if>

</#if>
</#list>
<#list ENTITYINFO.field![] as field>
<#if field.type="int" >
    /**
     * Get the formatted text version of ${field.name} field left padded with
     * zeros if less than minimum size.
     *
     * @param minDigits minimum size
     * @return the formatted String
     */
    public String format${field.name?cap_first}(int minDigits) {
        return StringX.padLeft(format${field.name?cap_first}(),minDigits,'0');
    }
<#elseif field.type="String" >
    /**
     * Get the formatted text version of ${field.name} field left padded with
     * zeros if less than minimum size.
     *
     * @param minChars minimum size
     * @return the formatted String
     */
    public String format${field.name?cap_first}(int minChars) {
        return StringX.padLeftIfInt(format${field.name?cap_first}(),minChars,'0');
    }
</#if>
</#list>
<#assign fireName = "no">
<#assign fireTitle = "no">
<#list ENTITYINFO.field![] as field>
<#if field.type == "ref" || field.type == "reference" >
<#list ENTITYINFO.displaynameformat as df >
<#list df.display as dp>
<#if dp.field = field.label >
<#assign fireName  = "yes" >
</#if>
</#list>
</#list>
<#if ENTITYINFO.displaytitleformat??>
<#list ENTITYINFO.displaytitleformat as df >
<#list df.display as dp>
<#if dp.field = field.label >
<#assign fireTitle = "yes" >
</#if>
</#list>
</#list>
<#else>
<#assign fireTitle = fireName >
</#if>
</#if>
</#list>
<#if fireName = "yes" || fireTitle = "yes" >

    private class ReferencedEntityTitleChangeListener extends Listener {

        @Override
        public void action(Object p) {
<#if fireName = "yes" >
            nameListenerFire();
</#if>
<#if fireTitle = "yes" >
            titleListenerFire();
</#if>
        }
    }
</#if>
}
