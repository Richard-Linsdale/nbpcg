<#--
    Copyright 2015-2017 Richard Linsdale.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

 -->
<#if license = "apache20" >
/*
 * Copyright ${copyright}.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
</#if>
<#if license = "gpl30" >
/*
 * Copyright (C) ${copyright}
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
</#if>
<#if license = "lgpl21" >
/*
 * Copyright (C) ${copyright}.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */
</#if>
<#-- Freemarker Template for ChildFactory class plus an inner classes for Nodes. -->
<#assign templateauthor = "Richard Linsdale (richard at theretiredprogrammer.uk)" />
<#assign ENTITYINFO = entityinfo[useentityinfo] >
<#assign haschildren = false>
<#list ENTITYINFO.child![] as c>
<#assign haschildren = true >
<#assign child = c.name?cap_first />
</#list>
<#if ENTITYINFO.customchildfactorypackage?? >
<#assign haschildren = true >
</#if>
package ${package};

import com.famfamfam.www.silkicons.Icons;
import java.awt.Component;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import static java.beans.BeanInfo.ICON_COLOR_16x16;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.text.DateFormat;
import java.text.MessageFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import javax.swing.Action;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import org.netbeans.spi.actions.AbstractSavable;
import org.openide.ErrorManager;
import org.openide.actions.CopyAction;
import org.openide.actions.CutAction;
import org.openide.actions.DeleteAction;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.Children;
import ${datapackage}.*;
import org.openide.nodes.PropertySupport;
import org.openide.nodes.Sheet;
import org.openide.util.ImageUtilities;
import org.openide.util.WeakListeners;
import org.openide.util.datatransfer.ExTransferable;
import org.openide.util.lookup.AbstractLookup;
import org.openide.util.lookup.InstanceContent;
<#list ENTITYINFO.child![] as c>
import static ${package}.${c.name?cap_first}Node.${c.name?upper_case}NODE_FLAVOR;
</#list>
import uk.theretiredprogrammer.accesscontrolmanager.topcomponents.Edit${ENTITYINFO.name};
import uk.theretiredprogrammer.nbpcglibrary.api.ApplicationLookup;
import static uk.theretiredprogrammer.nbpcglibrary.api.IdTimestampBaseEntity.COPYNEWSTATE;
import uk.theretiredprogrammer.nbpcglibrary.lifecycle.LibraryOnStop;
import static uk.theretiredprogrammer.nbpcglibrary.lifecycle.LibraryOnStop.isSavableEnabled;
import uk.theretiredprogrammer.nbpcglibrary.icons.SpecialIcons;
<#if haschildren >
import java.util.List;
import org.openide.actions.PasteAction;
import org.openide.nodes.NodeTransfer;
import org.openide.util.datatransfer.PasteType;
</#if>

/**
 * Node for ${ENTITYINFO.name}Node.
 *
 * (Class generated by NetBeans Platform Code Generator tools using ${DEFINITION_FILE}.  
 * Do not edit this file.  Apply any changes to the definition file and regenerate all files.)
 *
 * @author ${templateauthor}
 */
public class ${ENTITYINFO.name}Node extends AbstractNode implements PropertyChangeListener {

    private enum EntityStateChange {
        CREATE, LOAD, EDIT, SAVE, RESET, REMOVE
    };

    private enum EntityState {
        INIT, NEW, NEWEDITING, REMOVED, DBENTITY, DBENTITYEDITING
    };

    /**
     * Data Flavor for Nodes of type ${ENTITYINFO.name}Node
     */
    public static final DataFlavor ${ENTITYINFO.name?upper_case}NODE_FLAVOR = new DataFlavor(${ENTITYINFO.name}Node.class, "${ENTITYINFO.name}Node");
    private static final DateFormat DATETIME_ISO8601;
    
    static {
        DATETIME_ISO8601 = new SimpleDateFormat("yyyyMMddHHmmss");
        DATETIME_ISO8601.setLenient(false);
    }
    
    private final InstanceContent lookupcontent;
    private final NodeSavable savable = new NodeSavable();
    private EntityState state = EntityState.INIT;
    private ${ENTITYINFO.name}Entity entitybackup;   
<#if haschildren >
        private final ${ENTITYINFO.name}NodeChildFactory factory;
</#if>

    /**
     * Constructor Factory
     *
     * @param e the entity associated with this node
     */
    public static ${ENTITYINFO.name}Node create(${ENTITYINFO.name}Entity e){
        if (e.isPersistent()) {
            return new ${ENTITYINFO.name}Node(e, EntityState.DBENTITY, EntityStateChange.LOAD, new InstanceContent());
        }
        if (e.getId() == COPYNEWSTATE) {
          return new ${ENTITYINFO.name}Node(e, EntityState.NEWEDITING, EntityStateChange.EDIT, new InstanceContent());
        }
        return new ${ENTITYINFO.name}Node(e, EntityState.NEW, EntityStateChange.CREATE, new InstanceContent());
    }

    /**
     * Constructor Factory
     */
    public static ${ENTITYINFO.name}Node create(){
        return new ${ENTITYINFO.name}Node(${ENTITYINFO.name}Entity.createNew(), EntityState.NEW, EntityStateChange.CREATE, new InstanceContent());
    }
<#if haschildren >

        private ${ENTITYINFO.name}Node(${ENTITYINFO.name}Entity e, EntityState state, EntityStateChange statechange, InstanceContent lookupcontent) {
            this(e, state, statechange, new ${ENTITYINFO.name}NodeChildFactory(e.getId(), (id) -> new Claims(id)), lookupcontent);
        }

        @SuppressWarnings("LeakingThisInConstructor")
        private ${ENTITYINFO.name}Node(${ENTITYINFO.name}Entity e, EntityState state, EntityStateChange statechange, ${ENTITYINFO.name}NodeChildFactory factory, InstanceContent lookupcontent) {
            super(Children.create(factory, true), new AbstractLookup(lookupcontent));
            this.lookupcontent = lookupcontent;
            lookupcontent.add(e);
            this.factory = factory;
            e.addPropertyChangeListener(WeakListeners.propertyChange(this, e));
            this.state = state;
        entityStateChange(statechange);
        }
<#else>
   
    @SuppressWarnings("LeakingThisInConstructor")
    private ${ENTITYINFO.name}Node(${ENTITYINFO.name}Entity e, EntityState state, EntityStateChange statechange, InstanceContent lookupcontent) {
        super(Children.LEAF, new AbstractLookup(lookupcontent));
        this.lookupcontent = lookupcontent;
        lookupcontent.add(e);
        e.addPropertyChangeListener(WeakListeners.propertyChange(this, e));
        this.state = state;
        entityStateChange(statechange);
    }
</#if>

    public final ${ENTITYINFO.name}Entity getEntity() {
        return getLookup().lookup(${ENTITYINFO.name}Entity.class);
    }

<#if haschildren>
    /**
     * add a ${child} entity to the children model
     *
     * @param e the entity to add
     */
    public void add${child}(${child}Entity e){
        factory.add(e);
    }

    /**
     * remove a ${child} entity from the children model
     *
     * @param e the entity to remove
     */
    public void remove${child}(${child}Entity e){
        factory.remove(e);
    }

</#if>

    // ------------------------------------------------------------------------
    //
    //  Entity Getters and Setters (Facade)
    //
    // ------------------------------------------------------------------------

<#list ENTITYINFO.field![] as field>
<#if field.type = "ref" >

        /**
         * Get the ${field.name}.
         *
         * @return the ${field.name}
         */
        public final int get${field.name?cap_first}() {
            return getEntity().get${field.name?cap_first}();
        }

        /**
         * Define the ${field.name?cap_first}.
         *
         * @param ${field.name} the ${field.name}
         */
        public void set${field.name?cap_first}(int ${field.name}) {
            int old = getEntity().get${field.name?cap_first}();
            if (old != ${field.name}) {
                ensureEditing();
                getEntity().set${field.name?cap_first}(${field.name});
            }
        }
<#elseif field.type = "reference" >

    /**
     * Get the ${field.name?cap_first} Entity associated with this entity.
     *
     * @return the ${field.name?cap_first} entity
     */
    public ${field.references} get${field.name?cap_first}() {
        return ${field.name}.get();
    }

    /**
     * Set the ${field.name?cap_first} Entity associated with this entity.
     *
     * @param e the ${field.name} entity
     */
    public void set${field.name?cap_first}(${field.references} e) {
        if (e == null) {
            if (${field.name}.getPK() != null) {
                ensureEditing();
                ${field.name}.set();
            }
        } else {
            if (!e.getPK().equals(${field.name}.getPK())) {
                ensureEditing();
                ${field.name}.set(e.getPK());
            }
        }
    }
<#elseif field.type = "rootref" >
<#elseif field.type == "idx" >

    @Override
    public final int getIdx() {
        return idx;
    }

    @Override
    public void setIdx(int idx) {
        int old = getEntity().getIdx();
        if (old != idx) {
            ensureEditing();
            getEntity().setIdx(idx);
        }
    }

<#else>
    <#if field.type == "datetime">
    /**
     * Get the ${field.name}.
     *
     * @return the ${field.name}
     * @throws java.text.ParseException if problems
     */
        public final Date get${field.name?cap_first}() throws ParseException {
            return DATETIME_ISO8601.parse(getEntity().get${field.name?cap_first}());
        }
    <#else>
    /**
     * Get the ${field.name}.
     *
     * @return the ${field.name}
     */
        public final ${field.javatype} get${field.name?cap_first}() {
            return getEntity().get${field.name?cap_first}();
        }
    </#if>
    <#if !(field.hidden??) >

        /**
         * Define the ${field.name?cap_first}.
         *
         * @param ${field.name} the ${field.name}
         */
        public void set${field.name?cap_first}(${field.javatype} ${field.name}) {
        <#if field.type == "enum" >
            if (${field.name} == null) {
                if (getEntity().get${field.name?cap_first}() != null) {
                    ensureEditing();
                    getEntity().set${field.name?cap_first}(null);
                }
            } else {
                if (!${field.name}.equals(getEntity().get${field.name?cap_first}())) {
                    ensureEditing();
                    getEntity().set${field.name?cap_first}(${field.name});
                }
            }
        <#else>
            <#if field.type == "String" || field.type == "date" || field.type == "datetime">
                ${field.javatype} old = getEntity().get${field.name?cap_first}();
                if (!old.equals(${field.name})) {
            <#elseif field.type == "decimal" || field.type == "currency" >
                ${field.javatype} old = getEntity().get${field.name?cap_first}();
                if (old.compareTo(${field.name}) != 0) {
            <#else>
                ${field.javatype} old = getEntity().get${field.name?cap_first}();
                if (old != ${field.name}) {
            </#if>
                ensureEditing();
                getEntity().set${field.name?cap_first}(${field.name});
            }
        </#if>
        }
    </#if>
</#if>
</#list>

    // ------------------------------------------------------------------------
    //
    //   Icon, DisplayName and Title Management
    //
    // ------------------------------------------------------------------------
    
    @Override
    public void propertyChange(PropertyChangeEvent evt) {
<#list ENTITYINFO.displaynameformat as df >
        if ( 
<#list df.display as dp>
<#list ENTITYINFO.field![] as fd>
<#if fd.name == dp.field?lower_case >
            "${fd.name}".equals(evt.getPropertyName())<#if dp_has_next> || </#if>
</#if>
</#list>
</#list>
            ) {
            fireDisplayNameChange(null, getDisplayName());
            // TODO ---- need to move this to its own list of getters   
        }
</#list>
    }
    
    @Override
    public String getHtmlDisplayName() {
        return (state == EntityState.NEW || state == EntityState.NEWEDITING
                ? "<font color='#0000FF'><b>"
                : (state == EntityState.NEWEDITING || state == EntityState.DBENTITYEDITING
                        ? "<b>"
                        : ""))
                + getDisplayName();
}

    @Override
    public String getDisplayName() {
<#list ENTITYINFO.displaynameformat as df >
        return MessageFormat.format("${df.format}", 
<#list df.display as dp>
<#list ENTITYINFO.field![] as fd>
<#if fd.name == dp.field?lower_case >
<#if fd.type="reference" >
                getEntity().get${fd.name?cap_first}().getDisplayTitle()<#if dp_has_next>, </#if>
<#elseif fd.type="ref" >
                getParentNode().getDisplayName();<#if dp_has_next>, </#if>
<#elseif fd.type="int" >
                Integer.toString(getEntity().get${fd.name?cap_first}())<#if dp_has_next>, </#if>
<#elseif fd.type="idx"  >
                Integer.toString(getEntity().getIdx())<#if dp_has_next>, </#if>
<#elseif fd.type="long" >
                Long.toString(getEntity().get${fd.name?cap_first}())<#if dp_has_next>, </#if>
<#elseif fd.type="boolean" >
                getEntity().get${fd.name?cap_first}()? "Yes": "No"<#if dp_has_next>, </#if>
<#elseif fd.type="date" || fd.type="datetime" >
                getEntity().get${fd.name?cap_first}().toString()<#if dp_has_next>, </#if>
<#elseif fd.type="currency" || fd.type="decimal" >
                getEntity().get${fd.name?cap_first}().toPlainString()<#if dp_has_next>, </#if>
<#elseif fd.type="String" ||  fd.type="enum" || fd.type="password" >
                getEntity().get${fd.name?cap_first}()<#if dp_has_next>, </#if>
</#if>
</#if>
</#list>
</#list>
                    );
</#list>
    }

    public String getDisplayTitle() {
<#if ENTITYINFO.displaytitleformat??>
<#list ENTITYINFO.displaytitleformat as df >
        return MessageFormat.format("${df.format}", 
<#list df.display as dp>
<#list ENTITYINFO.field![] as fd>
<#if fd.name == dp.field?lower_case >
<#if fd.type="reference" >
                getEntity().get${fd.name?cap_first}().getDisplayTitle()<#if dp_has_next>, </#if>
<#elseif fd.type="ref" >
                getParentNode().getDisplayName();<#if dp_has_next>, </#if>
<#elseif fd.type="int" >
                Integer.toString(getEntity().get${fd.name?cap_first}())<#if dp_has_next>, </#if>
<#elseif fd.type="idx"  >
                Integer.toString(getEntity().getIdx())<#if dp_has_next>, </#if>
<#elseif fd.type="long" >
                Long.toString(getEntity().get${fd.name?cap_first}())<#if dp_has_next>, </#if>
<#elseif fd.type="boolean" >
                getEntity().get${fd.name?cap_first}()? "Yes": "No"<#if dp_has_next>, </#if>
<#elseif fd.type="date" || fd.type="datetime" >
                getEntity().get${fd.name?cap_first}().toString()<#if dp_has_next>, </#if>
<#elseif fd.type="currency" || fd.type="decimal" >
                getEntity().get${fd.name?cap_first}().toPlainString()<#if dp_has_next>, </#if>
<#elseif fd.type="String" ||  fd.type="enum" || fd.type="password" >
                getEntity().get${fd.name?cap_first}()<#if dp_has_next>, </#if>
</#if>
</#if>
</#list>
</#list>
                    );
</#list>
<#else>
        return getDisplayName();
</#if>
    }

    public String getSortKey() {
<#if ENTITYINFO.sortformat?? >
<#list ENTITYINFO.displaysortformat as df >
        return MessageFormat.format("${df.format}", 
<#list df.display as dp>
<#list ENTITYINFO.field![] as fd>
<#if fd.name == dp.field?lower_case >
<#if fd.type="reference" >
                getEntity().get${fd.name?cap_first}().getDisplayTitle()<#if dp_has_next>, </#if>
<#elseif fd.type="ref" >
                getParentNode().getDisplayName();<#if dp_has_next>, </#if>
<#elseif fd.type="int" >
                Integer.toString(getEntity().get${fd.name?cap_first}())<#if dp_has_next>, </#if>
<#elseif fd.type="idx"  >
                Integer.toString(getEntity().getIdx())<#if dp_has_next>, </#if>
<#elseif fd.type="long" >
                Long.toString(getEntity().get${fd.name?cap_first}())<#if dp_has_next>, </#if>
<#elseif fd.type="boolean" >
                getEntity().get${fd.name?cap_first}()? "Yes": "No"<#if dp_has_next>, </#if>
<#elseif fd.type="date" || fd.type="datetime" >
                getEntity().get${fd.name?cap_first}().toString()<#if dp_has_next>, </#if>
<#elseif fd.type="currency" || fd.type="decimal" >
                getEntity().get${fd.name?cap_first}().toPlainString()<#if dp_has_next>, </#if>
<#elseif fd.type="String" ||  fd.type="enum" || fd.type="password" >
                getEntity().get${fd.name?cap_first}()<#if dp_has_next>, </#if>
</#if>
</#if>
</#list>
</#list>
                    );
</#list>
<#else>
        return getDisplayTitle();
</#if>
    }

    @Override
    public Image getIcon(int type) {
        return ${ENTITYINFO.name}Rules.areAllRulesValid(new StringBuilder(), getEntity())
                ? Icons.get("${ENTITYINFO.icon}")
                : ImageUtilities.mergeImages(Icons.get("${ENTITYINFO.icon}"), SpecialIcons.get("errormarker"), 0, 6);
    }

    @Override
    public Image getOpenedIcon(int type) {
        return getIcon(type);
    }

    // ------------------------------------------------------------------------
    //
    //                         CRUD OPERATIONS
    //
    // ------------------------------------------------------------------------
    
    /**
     * Save this entity to entity storage.
     *
     * @param sb Stringbuilder object used to collect any failure messages
     * @return true if save is successful
     */
    public boolean save(StringBuilder sb) {
        ${ENTITYINFO.name}Rest rest;
        switch (state) {
            case DBENTITY:
                return true;
            case REMOVED:
                return false;
            case NEW:
            case NEWEDITING:
                if (!${ENTITYINFO.name}Rules.areAllRulesValid(sb, getEntity())) {
                    return false;
                }
                rest = ApplicationLookup.getDefault().lookup(${ENTITYINFO.name}Rest.class);
                getEntity().copy(rest.create(getEntity()));
                state = EntityState.DBENTITY;
                // TODO - we need to refresh the child list
                break;
            case DBENTITYEDITING:
                if (!${ENTITYINFO.name}Rules.areAllRulesValid(sb, getEntity())) {
                    return false;
                }
                rest = ApplicationLookup.getDefault().lookup(${ENTITYINFO.name}Rest.class);
                getEntity().copy(rest.update(getEntity().getId(), getEntity()));
                state = EntityState.DBENTITY;
                break;
            default:
                if (!${ENTITYINFO.name}Rules.areAllRulesValid(sb, getEntity())) {
                    return false;
                }
        }
        entityStateChange(EntityStateChange.SAVE);
        return true;
    }

    @Override
    public final void destroy() throws IOException {
<#if haschildren>
        factory.clearChildren();
</#if>
        switch (state) {
            case NEW:
            case NEWEDITING:
                ((${ENTITYINFO.parentname}Node)getParentNode()).remove${ENTITYINFO.name}(getEntity());
                state = EntityState.REMOVED;
                entityStateChange(EntityStateChange.REMOVE);
                return;
            case DBENTITY:
            case DBENTITYEDITING:
                ${ENTITYINFO.name}Rest rest = ApplicationLookup.getDefault().lookup(${ENTITYINFO.name}Rest.class);
                rest.delete(getEntity().getId());
                ((${ENTITYINFO.parentname}Node)getParentNode()).remove${ENTITYINFO.name}(getEntity());
                state = EntityState.REMOVED;
                entityStateChange(EntityStateChange.REMOVE);
        }
    }

    // ------------------------------------------------------------------------
    //
    //                         STATE MANAGEMENT
    //
    // ------------------------------------------------------------------------
    
    /**
     * Switch into an editing state, updating state. If already in state then
     * this does nothing.
     */
    private void ensureEditing() {
        switch (state) {
            case NEW:
                state = EntityState.NEWEDITING;
                break;
            case DBENTITY:
                state = EntityState.DBENTITYEDITING;
                break;
            default:
                return;
        }
        entitybackup = ${ENTITYINFO.name}Entity.createCopy(getEntity());
        entityStateChange(EntityStateChange.EDIT);
    }

    public void cancelEdit() {
        switch (state) {
            case NEWEDITING:
                state = EntityState.NEW;
                break;
            case DBENTITYEDITING:
                state = EntityState.DBENTITY;
                break;
            default:
                return;
        }
        getEntity().copy(entitybackup);
        entityStateChange(EntityStateChange.RESET);
    }

    private void entityStateChange(EntityStateChange esc) {
        switch (esc) {
            case EDIT:
                savable.add();
                break;
            case LOAD:
            case SAVE:
            case REMOVE:
            case RESET:
                savable.remove();
        }
        fireIconChange();
        fireOpenedIconChange();
        fireDisplayNameChange("old", getDisplayName());
        //firePropertyChange("DISPLAYTITLE", null, getDisplayTitle());
    }

    private class NodeSavable<E> extends AbstractSavable implements Icon {

        private Icon icon;
        private boolean isRegisteredAsOutstanding = false;

        public void add() {
            if (isSavableEnabled()) {
                if (getLookup().lookup(NodeSavable.class) == null) {
                    register();
                    lookupcontent.add(this);
                }
                icon = null;
            } else {
                if (!isRegisteredAsOutstanding) {
                    LibraryOnStop.incRegisterOutstanding();
                    isRegisteredAsOutstanding = true;
                }
            }
        }

        public void remove() {
            if (isSavableEnabled()) {
                lookupcontent.remove(this);
                unregister();
            } else {
                if (isRegisteredAsOutstanding) {
                    LibraryOnStop.decRegisterOutstanding();
                    isRegisteredAsOutstanding = false;
                }
            }
        }

        @Override
        protected void handleSave() throws IOException {
            StringBuilder sb = new StringBuilder();
            if (!${ENTITYINFO.name}Node.this.save(sb)) {
                EventQueue.invokeLater(new ReRegister());
                LibraryOnStop.incRegisterOutstanding();
                // TODO - should we place the error message in a visible place
            }
        }

        private class ReRegister implements Runnable {

            @Override
            public void run() {
                NodeSavable.this.register();
                LibraryOnStop.decRegisterOutstanding();
            }
        }

        @Override
        protected String findDisplayName() {
            return ${ENTITYINFO.name}Node.this.getDisplayName();
        }

        @Override
        public boolean equals(Object obj) {
            if (obj instanceof NodeSavable) {
                return node() == ((NodeSavable) obj).node();
            }
            return false;
        }

        @Override
        public int hashCode() {
            return node().hashCode();
        }

        ${ENTITYINFO.name}Node node() {
            return ${ENTITYINFO.name}Node.this;
        }

        @Override
        public void paintIcon(Component c, Graphics g, int x, int y) {
            new ImageIcon(getIcon(ICON_COLOR_16x16)).paintIcon(c, g, x, y);
        }

        @Override
        public int getIconWidth() {
            if (icon == null) {
                icon = new ImageIcon(getIcon(ICON_COLOR_16x16));
            }
            return icon.getIconWidth();
        }

        @Override
        public int getIconHeight() {
            if (icon == null) {
                icon = new ImageIcon(getIcon(ICON_COLOR_16x16));
            }
            return icon.getIconHeight();
        }
    }
   
    @Override
    public Action[] getActions(boolean context) {
        return new Action[]{
            Edit${ENTITYINFO.name}.get(Edit${ENTITYINFO.name}.class),
            Undo${ENTITYINFO.name}.get(Undo${ENTITYINFO.name}.class),
<#if haschildren>
            Add${child}.get(Add${child}.class),
            PasteAction.get(PasteAction.class),
</#if>
            CutAction.get(CutAction.class),
            CopyAction.get(CopyAction.class),
            DeleteAction.get(DeleteAction.class),
<#if ENTITYINFO.orderable = "yes" >
            MoveUpAction.get(MoveUpAction.class),
            MoveDownAction.get)MoveDownAction.class),
</#if>
        };
    }


    @Override
    public Action getPreferredAction() {
        return Edit${ENTITYINFO.name}.get(Edit${ENTITYINFO.name}.class);
    }

    @Override
    public Sheet createSheet() {
        Sheet sheet = Sheet.createDefault();
        Sheet.Set set = Sheet.createPropertiesSet();
        ${ENTITYINFO.name}Entity obj = getEntity();
        try {
<#list ENTITYINFO.field![] as field>
<#if !(field.hidden?? || field.type == "rootref" || field.type == "ref" || field.type == "reference" ) >
            Property ${field.name}Prop = new PropertySupport.Reflection(obj, ${field.javatype}.class, "${field.name}");
            ${field.name}Prop.setName("${field.name}");
            set.put(${field.name}Prop);
</#if>
</#list>
        } catch (NoSuchMethodException ex) {
            ErrorManager.getDefault();
        }
        sheet.put(set);
        return sheet;
    }

    @Override
    public final boolean canCopy() {
        return true;
    }

    @Override
    public final boolean canCut() {
        return true;
    }

    @Override
    public final boolean canDestroy() {
        return true;
    }

<#if haschildren>
    // DND target support
    @Override
    public PasteType getDropType(final Transferable t, int arg1, int arg2) {
        if (t.isDataFlavorSupported(${child?upper_case}NODE_FLAVOR)) {
            return new AllowedPasteType(t);
        } else {
            return null;
        }
    }

    // CUT / COPY target support
    @Override
    public void createPasteTypes(Transferable t, List<PasteType> s) {
        super.createPasteTypes(t, s);
        PasteType p = getDropType(t, 0, 0);
        if (p != null) {
            s.add(p);
        }
    }

    private class AllowedPasteType extends PasteType {

        private final Transferable t;
        
        public AllowedPasteType(Transferable t) {
            this.t = t;
        }

        @Override
        public Transferable paste() throws IOException {
            ${child}Node node = (${child}Node) NodeTransfer.node(t, NodeTransfer.MOVE);
            if (node != null) {
                ((UserNode)node.getParentNode()).remove${child}(node.getEntity());
                add${child}(node.getEntity());
                return null;
            }
            node = (${child}Node) NodeTransfer.node(t, NodeTransfer.COPY);
            if (node != null) {
                factory.add(${child}Entity.createNewCopy(node.getEntity()));
            }
            return null;
        }
    }

</#if>
    @Override
    public Transferable clipboardCut() throws IOException {
        ExTransferable added = ExTransferable.create(super.clipboardCut());
        added.put(new ${ENTITYINFO.name}NodeTransfer());
        return added;
    }

    @Override
    public Transferable clipboardCopy() throws IOException {
        ExTransferable added = ExTransferable.create(super.clipboardCopy());
        added.put(new ${ENTITYINFO.name}NodeTransfer());
        return added;
    }

    private class ${ENTITYINFO.name}NodeTransfer extends ExTransferable.Single {

        public ${ENTITYINFO.name}NodeTransfer() {
            super(${ENTITYINFO.name?upper_case}NODE_FLAVOR);
        }

        @Override
        protected ${ENTITYINFO.name}Node getData() {
            return ${ENTITYINFO.name}Node.this;
        }
    }
}
 