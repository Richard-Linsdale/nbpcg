<#--
 * Copyright (C) 2014 Richard Linsdale (richard.linsdale at blueyonder.co.uk)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 -->
<#if license = "gpl30" >
/*
 * Copyright (C) 2014 Richard Linsdale (richard.linsdale at blueyonder.co.uk)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
</#if>
<#if license = "lgpl21" >
/*
 * Copyright (C) 2014 Richard Linsdale (richard.linsdale at blueyonder.co.uk).
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */
</#if>
<#-- Freemarker Template for ChildFactory class plus an inner classes for Nodes. -->
<#assign templateauthor = "Richard Linsdale (richard.linsdale at blueyonder.co.uk)" />
<#assign NODEINFO = nodeinfo[usenodeinfo] >
<#if type = "Icon" >
<#assign type2 = "Icon" />
<#else>
<#assign type2 = "Tree" />
</#if>
package ${package};

import java.awt.datatransfer.DataFlavor;
import java.util.List;
import javax.swing.Action;
import  ${datapackage}.*;
import uk.org.rlinsdale.nbpcglibrary.node.RegisterNodeSavedAction;
import uk.org.rlinsdale.nbpcglibrary.node.RegisterNodeSavedActions;
import uk.org.rlinsdale.nbpcglibrary.data.entity.*;
import uk.org.rlinsdale.nbpcglibrary.node.nodes.*;
import uk.org.rlinsdale.nbpcglibrary.node.properties.*;
import uk.org.rlinsdale.nbpcglibrary.common.*;
import org.openide.nodes.Node;
import org.openide.nodes.PropertySupport;

/**
 * ${type}NodeChildFactory from ${NODEINFO.name}.
 *
 * (Class generated by NetBeans Platform Code Generator tools using ${DEFINITION_FILE}.  
 * Do not edit this file, apply any changes to the definition file and regenerate all files.)
 *
 * @author ${templateauthor}
 */
<#if NODEINFO.isroot??>
public class ${NODEINFO.name}ChildFactory extends RootChildFactory<${NODEINFO.entity}> {
<#else>
public class ${NODEINFO.name}ChildFactory extends BasicChildFactory<${NODEINFO.entity}> {
</#if>

<#list NODEINFO.child![] as child>
    public static final DataFlavor ${child.name?upper_case}_FLAVOR = new DataFlavor(${child.name}.class, "${child.name}");
    private int offsetMin${child.entity}s;
    private int offsetMax${child.entity}s;
</#list>

<#if NODEINFO.isroot??>
    public ${NODEINFO.name}ChildFactory(${NODEINFO.entity} parent) {
        super(parent);
        enableChangeListening("${NODEINFO.name}ChildFactory", parent);
    }   

<#else>
    public ${NODEINFO.name}ChildFactory(${NODEINFO.entity} parent) {
        super("${NODEINFO.name}", parent, ${NODEINFO.entity}.EM.class);
        enableChangeListening("${NODEINFO.name}ChildFactory", parent);
    }  

</#if>
    /**
     * Create the list of Child Entities
     *
     * @param list the list into which child entities are to be added
     * @return true
     */
    @Override
    protected boolean createKeys(List<Entity> list) {
<#assign previous = "" >
<#list NODEINFO.child![] as child>
<#if previous = "" >
        offsetMin${child.entity}s = 0; 
<#else>
        offsetMin${child.entity}s = ${previous} + 1;
</#if>
        List<${child.entity}> ${child.entity?uncap_first}s = getParentEntity().get${child.entity}s();
        list.addAll(${child.entity?uncap_first}s);
        offsetMax${child.entity}s = offsetMin${child.entity}s + ${child.entity?uncap_first}s.size() -1;
<#assign previous = "offsetMax${child.entity}s" >
</#list>
        return true;
    }

    /**
     * Create a Child Node from a given Child Entity
     *
     * @param e the Child Entity
     * @return the Child Node
     */
    @Override
    protected Node createNodeForKey(Entity e) {
<#list NODEINFO.child![] as child>
        if (e instanceof ${child.entity}) {
            return new ${child.name}((${child.entity}) e);
        }
</#list>
        throw new LogicException("${NODEINFO.name}ChildFactory.createNodeforKey(..) was given an unsupported entity class");
    }
<#list NODEINFO.child![] as child>

    public final int getOffsetMin${child.entity}s() {
        return offsetMin${child.entity}s;
    }
    
    public final int getOffsetMax${child.entity}s() {
        return offsetMax${child.entity}s;
    }
</#list>
<#list NODEINFO.child![] as child>
<#assign CHILDNODEINFO = nodeinfo[child.nodekey] >
<#assign haschildren = false>
<#assign haseditablechildren = false>
<#list CHILDNODEINFO.child![] as c>
<#assign haschildren = true >
<#assign haseditablechildren = haseditablechildren | (c.access = "rw") >
</#list>

    @RegisterNodeSavedActions({
<#if child.orderable = "yes">
            @RegisterNodeSavedAction(id = "linsdale.nbpcg.nodesupportlib.actions.NodeReorderAction",
                    node = "${child.name}", position = 810),
</#if>
<#if haseditablechildren >
            @RegisterNodeSavedAction(id = "linsdale.nbpcg.nodesupportlib.actions.NodePasteAction",
                    node = "${child.name}", position = 830),
</#if>
<#if child.access = "rw" >
            @RegisterNodeSavedAction(id = "linsdale.nbpcg.nodesupportlib.actions.NodeCutAction",
                    node = "${child.name}",
                    position = 850, separator = 800),
            @RegisterNodeSavedAction(id = "linsdale.nbpcg.nodesupportlib.actions.NodeCopyAction",
                    node = "${child.name}", position = 870),
            @RegisterNodeSavedAction(id = "linsdale.nbpcg.nodesupportlib.actions.NodeDeleteAction",
                    node = "${child.name}", position = 890),
</#if>
<#if child.orderable = "yes" >
            @RegisterNodeSavedAction(id = "linsdale.nbpcg.nodesupportlib.actions.NodeMoveUpAction",
                    node = "${child.name}", position = 910),
            @RegisterNodeSavedAction(id = "linsdale.nbpcg.nodesupportlib.actions.NodeMoveDownAction",
                    node = "${child.name}", position = 930),
</#if>
        })
    private static void register${child.name}Annotations() {} // a dummy method
 
<#if haschildren >
   /**
    * Node for ${child.name}.
    */
    public class ${child.name} extends ${type2}Node${child.access?upper_case}<${child.entity}> {

        private final ${child.name}ChildFactory cf;

        /**
         * Constructor
         *
         * @param e the entity associated with this node
         */
        public ${child.name}(${child.entity} e) {
            this(e, new ${child.name}ChildFactory(e));
        }

        private ${child.name}(${child.entity} e, ${child.name}ChildFactory cf) {
            super("${child.name}", "${child.icon}", e, cf, ${child.entity}.EM.class,
                new DataFlavorAndAction[] {
<#list CHILDNODEINFO.child![] as c>
                    new DataFlavorAndAction(${child.name}ChildFactory.${c.name?upper_case}_FLAVOR, DataFlavorAndAction.COPYCUT<#if c.orderable = "yes">MOVE</#if>),
<#if c.copymovenode??>
<#assign COPYMOVENODEINFO = nodeinfo[c.copymovenode] >
                    new DataFlavorAndAction(${COPYMOVENODEINFO.parententity}ChildFactory.${COPYMOVENODEINFO.name?upper_case}_FLAVOR, DataFlavorAndAction.COPYMOVE),
</#if>
</#list>
                    }
                    // TODO - decide on state of this cut/destroy flag  - currently it is always true
                 <#if child.access = "rw">, true</#if>);
            this.cf = cf;
        }
<#else>
   /**
    * Node for ${child.name}.
    */
    public class ${child.name} extends ${type2}Node${child.access?upper_case}<${child.entity}> {
        /**
         * Constructor
         *
         * @param e the entity associated with this node
         */
        public ${child.name}(${child.entity} e) {
            super("${child.name}", "${child.icon}", e, ${child.entity}.EM.class
                    // TODO - decide on state of this cut/destroy flag  - currently it is always true
                    <#if child.access = "rw">, true</#if>);
        }
</#if>

        @Override
        protected DataFlavor _getDataFlavor() {
           return ${child.name?upper_case}_FLAVOR; 
        }

         /**
         * Get the node display name
         *
         * @return the display name
         */
        @Override
        public String getDisplayName() {
            return  ${child.name}Display.getDisplayName(getEntity(), "#undefined#");
        }

        /**
         * Get the node display title
         *
         * @return the display title
         */
        @Override
        public String getDisplayTitle() {
            return  ${child.name}Display.getDisplayTitle(getEntity(), "#undefined#");
        }

<#if child.access = "rw" >
        IntegerReadonlyProperty idproperty;
<#list CHILDNODEINFO.field![] as field>
<#if field.type != "rootref" >
        StringReadonlyProperty ${field.name}property;
</#if>
</#list>

</#if>
        @Override
        protected List<PropertySupport.ReadOnly<?>> createPropertyItems(List<PropertySupport.ReadOnly<?>> props) {
            ${child.entity} e =  getEntity();
            if (e != null) {
                props.add(new StringReadonlyProperty("Node Type", "${child.name}"));
<#if child.access = "rw" >
                props.add(idproperty = new IntegerReadonlyProperty("Id",e.getId()));
<#else>
                props.add(new IntegerReadonlyProperty("Id",e.getId()));
</#if>
<#list CHILDNODEINFO.field![] as field>
<#if field.type != "rootref" >
<#if child.access = "rw" >
                props.add(${field.name}property = new StringReadonlyProperty("${field.label}", ${child.name}Display.format${field.name?cap_first}(e)));
<#else>
                props.add(new StringReadonlyProperty("${field.label}", ${child.name}Display.format${field.name?cap_first}(e)));
</#if>
</#if>
</#list>
            }
            return props;
        }

<#if child.access = "rw" >
        @Override
        protected void _processFieldChange(IntWithDescription field) {
            ${child.entity} e =  getEntity();
            if (field.equals(FieldChangeListenerParams.ALLFIELDS)) {
                if (e != null && idproperty != null) {
                    idproperty.update(e.getId());
<#list CHILDNODEINFO.field![] as field>
<#if field.type != "rootref" >
                    ${field.name}property.update(${child.name}Display.format${field.name?cap_first}(e));
</#if>
</#list>
                propertyChange();
                }
                nameChange();
                titleChange();
            } else if (field.equals(FieldChangeListenerParams.IDFIELD)) {
                if (e != null && idproperty != null) {
                    idproperty.update(e.getId());
                    propertyChange("Id");
                }
<#list CHILDNODEINFO.field![] as field>
<#if field.type = "rootref" >
<#elseif field.type = "idx" >
            } else if (field.equals(FieldChangeListenerParams.${field.name?upper_case}FIELD)) {
                if (e != null && ${field.name}property != null) {
                    ${field.name}property.update(${child.name}Display.format${field.name?cap_first}(e));
                    propertyChange("${field.label}");
                }
<#else>
            } else if (field.equals(${child.entity}.${field.name?upper_case}FIELD)) {
                if (e != null && ${field.name}property != null) {
                    ${field.name}property.update(${child.name}Display.format${field.name?cap_first}(e));
                    propertyChange("${field.label}");
                }
<#assign namechange = "no">
<#list CHILDNODEINFO.displaynameformat as df >
<#list df.display as dp>
<#if dp.field = field.label >
<#assign namechange = "yes" >
</#if>
</#list>
</#list>
<#if namechange = "yes" >
                nameChange();
</#if>
<#assign titlechange = "no">
<#if CHILDNODEINFO.displaytitleformat??>
<#list CHILDNODEINFO.displaytitleformat as df >
<#list df.display as dp>
<#if dp.field = field.label >
<#assign titlechange = "yes" >
</#if>
</#list>
</#list>
<#else>
<#assign titlechange = namechange >
</#if>
<#if titlechange = "yes" >
                titleChange();
</#if>
</#if>
</#list>
            }
        }
        
</#if>
        @Override
        protected void _moveAddChild(Entity child) {
<#list CHILDNODEINFO.child![] as c>
<#if c.copymoveentity??>
            if (child instanceof ${c.copymoveentity}) {
                ${c.entity}.EM em = ${c.entity}.getEM();
                ${c.entity} e = em.getNew(getEntity());
                e.set${c.copymovefield?cap_first}((${c.copymoveentity}) child);
                return;
            }
</#if>
</#list>
            _cutAddChild(child);
        }

        @Override
        protected void _cutAddChild(Entity child) {
<#list CHILDNODEINFO.child![] as c>
            if (child instanceof ${c.entity}) {
                getEntity().add${c.entity}((${c.entity}) child);
                return;
            }
</#list>
            throw new LogicException("${child.entity} Entity does not have a child of the requested class (" + child.getClass().getSimpleName() + ")");
        }

        @Override
        protected void _copyAddChild(Entity child) {
<#list CHILDNODEINFO.child![] as c>
            if (child instanceof ${c.entity}) {
                ${c.entity}.getEM().getNew((${c.entity})child ,getEntity());
                return;
            }
<#if c.copymoveentity??>
            if (child instanceof ${c.copymoveentity}) {
                ${c.entity}.EM em = ${c.entity}.getEM();
                ${c.entity} e = em.getNew(getEntity());
                e.set${c.copymovefield?cap_first}((${c.copymoveentity}) child);
                return;
            }
</#if>
</#list>
            throw new LogicException("${child.entity} Entity does not have a child of the requested class (" + child.getClass().getSimpleName() + ")");
        }

<#if child.access = "rw" >
        @Override
        protected void _cutAndPasteRemove() {
            getParentEntity().remove${child.entity}(getEntity());
        }

        @Override
        protected void _deleteRemove() {
            getEntity().remove();
        }

</#if>
        @Override
        protected void _moveReorderChildByFlavor(DataFlavor df, int[] perm) {
<#list CHILDNODEINFO.child![] as c>
<#if c.orderable = "yes" >
            if (df == ${CHILDNODEINFO.name}ChildFactory.${c.name?upper_case}_FLAVOR) {
                getEntity().reorder${c.entity}s(perm, cf.getOffsetMin${c.entity}s(), cf.getOffsetMax${c.entity}s());
                return;
            }
</#if>
</#list>
            throw new LogicException("${child.entity} Entity does not have a child of the requested DataFlavor that is reorderable");
        }

        @Override
        public Action getPreferredAction() {
            return findDefaultAction("${child.name}");
        }

        @Override
        public Action[] getActions(boolean context) {
            return findActions("${child.name}");
        }
    }

    public static class ${child.name}Display {

        public static String getDisplayName(${child.entity} e, String undefined) {
<#list CHILDNODEINFO.displaynameformat as df >
            if (e != null) {
                return String.format("${df.format}", new Object[] {<#list df.display as dp>format${dp.field}(e)<#if dp_has_next>, </#if></#list>});
            } else {
                return undefined;
            }
</#list>
        }

        public static String getDisplayTitle(${child.entity} e, String undefined) {
<#if CHILDNODEINFO.displaytitleformat??>
<#list CHILDNODEINFO.displaytitleformat as df>
            if (e != null) {
                return String.format("${df.format}", new Object[] {<#list df.display as dp>format${dp.field}(e)<#if dp_has_next>, </#if></#list>});
            } else {
                return undefined;
            }
</#list>
<#else>
            return getDisplayName(e,undefined);
</#if>
        }

public static String getSort(${child.entity} e, String undefined) {
<#if CHILDNODEINFO.sortformat?? >
<#list CHILDNODEINFO.sortformat as df>
            if (e != null) {
                return String.format("${df.format}", new Object[] {<#list df.display as dp>format${dp.field}(e<#if dp.length??>, ${dp.length}</#if>)<#if dp_has_next>, </#if></#list>});
            } else {
                return undefined;
            }
</#list>
<#else>
            return getDisplayTitle(e,undefined);
</#if>
        }

<#list CHILDNODEINFO.field![] as field>

        public static String format${field.name?cap_first}(${child.entity} e) {
<#if field.type="reference" >
            return ${field.displaykey}Display.getDisplayName(e.get${field.name?cap_first}(), "");
<#elseif field.type="ref" >
        return ${field.displaykey}Display.getDisplayName(e.get${field.name?cap_first}(), "");
<#elseif field.type="int" >
            return Integer.toString(e.get${field.name?cap_first}());
<#elseif field.type="idx"  >
            return Integer.toString(e.getIndex());
<#elseif field.type="long" >
            return Long.toString(e.get${field.name?cap_first}());
<#elseif field.type="boolean" >
            return e.get${field.name?cap_first}()? "Yes": "No";
<#elseif field.type="date" || field.type="datetime" >
            return e.get${field.name?cap_first}().toString();
<#elseif field.type="String" ||  field.type="enum" >
            return e.get${field.name?cap_first}();
</#if>
        }
</#list>
<#list CHILDNODEINFO.field![] as field>
<#if field.type="int" >

        public static String format${field.name?cap_first}(${child.entity} e, int minDigits) {
            return StringX.padLeft(format${field.name?cap_first}(e),minDigits,'0');
        }
<#elseif field.type="String" >

    public static String format${field.name?cap_first}(${child.entity} e, int minDigits) {
            return StringX.padLeftIfInt(format${field.name?cap_first}(e),minDigits,'0');
        }
</#if>
</#list>
    }
</#list>
}
