/*
 * Copyright (C) 2014 Richard Linsdale (richard.linsdale at blueyonder.co.uk)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
<#-- Freemarker Template for Root Node class -->
<#assign templateauthor = "Richard Linsdale (richard.linsdale at blueyonder.co.uk)" />
<#assign NODEINFO = nodeinfo[usenodeinfo] >
package ${package};

import java.awt.datatransfer.DataFlavor;
import java.util.List;
import javax.swing.Action;
import ${datapackage}.*;
import linsdale.nbpcg.datasupportlib.entity.*;
import linsdale.nbpcg.annotations.RegisterNodeSavedAction;
import linsdale.nbpcg.annotations.RegisterNodeSavedActions;
import linsdale.nbpcg.nodesupportlib.nodes.DataFlavorAndAction;
import linsdale.nbpcg.nodesupportlib.nodes.RootNode;
import linsdale.nbpcg.nodesupportlib.properties.StringReadonlyProperty;
import linsdale.nbpcg.supportlib.LogicException;
import org.openide.nodes.*;

/**
 * ${type}Node for ${NODEINFO.entity}
 *
 * (Class generated by NetBeans Platform Code Generator tools using ${DEFINITION_FILE}.  
 * Do not edit this file, apply any changes to the definition file and regenerate all files.)
 *
 * @author ${templateauthor}
 */
public class ${NODEINFO.name} extends RootNode<${NODEINFO.entity}> {

    private final ${NODEINFO.name}ChildFactory cf;

   /**
     * Constructor
     */
    public ${NODEINFO.name}() {
        this(${NODEINFO.entity}.getRoot());
    }

    private ${NODEINFO.name}(${NODEINFO.entity} e){
        this(e, new ${NODEINFO.name}ChildFactory(e));
    }

    private ${NODEINFO.name}(${NODEINFO.entity} e, ${NODEINFO.name}ChildFactory cf) {
        super("${NODEINFO.icon}", e, cf, new DataFlavorAndAction[] {<#list NODEINFO.child![] as child>new DataFlavorAndAction(${NODEINFO.name}ChildFactory.${child.name?upper_case}_FLAVOR, DataFlavorAndAction.COPYCUT<#if child.orderable??>MOVE</#if>), </#list>});
        this.cf = cf;
    }

    /**
     * Get the node display name
     *
     * @return the display name
     */
    @Override
    public String getDisplayName() {
            return "${NODEINFO.label}";
    }

    @Override
    protected List<PropertySupport.ReadOnly<?>> createPropertyItems(List<PropertySupport.ReadOnly<?>> props) {
        props.add(new StringReadonlyProperty("Node Type", "${NODEINFO.name}"));
        return props;
    }

    @RegisterNodeSavedActions({
<#list NODEINFO.child![] as child>
<#if child.access = "rw" > 
        @RegisterNodeSavedAction(id = "linsdale.nbpcg.nodesupportlib.actions.NodePasteAction",
                node = "${NODEINFO.name}", position = 830, separator = 800),
</#if>
<#if child.orderable = "yes">
        @RegisterNodeSavedAction(id = "linsdale.nbpcg.nodesupportlib.actions.NodeReorderAction",
                node = "${NODEINFO.name}", position = 810, separator = 800),
        @RegisterNodeSavedAction(id = "linsdale.nbpcg.nodesupportlib.actions.NodeMoveUpAction",
                node = "${NODEINFO.name}", position = 910),
        @RegisterNodeSavedAction(id = "linsdale.nbpcg.nodesupportlib.actions.NodeMoveDownAction",
                node = "${NODEINFO.name}", position = 930),
</#if>
</#list>
        })
    private static void register${NODEINFO.name}Annotations() {} // a dummy method 

    @Override
    public Action getPreferredAction() {
         return findDefaultAction("${NODEINFO.name}");
    }

    @Override
    public Action[] getActions(boolean context) {
        return findActions("${NODEINFO.name}");
    }

    @Override
    protected void _moveAddChild(Entity child) {
        _cutAddChild(child);
    }

    @Override
    protected void _cutAddChild(Entity child) {
<#list NODEINFO.child![] as child>
<#if child.access = "rw" >
        if (child instanceof ${child.entity}) {
            getEntity().add${child.entity}((${child.entity}) child);
            return;
        }
</#if>
</#list>
        throw new LogicException("${NODEINFO.entity} Entity does not have a child of the requested class (" + child.getClass().getSimpleName() + ")");
    }

    @Override
    protected void _copyAddChild(Entity child) {
<#list NODEINFO.child![] as child>
<#if child.access = "rw" >
        if (child instanceof ${child.entity}) {
            ${child.entity}.getEM().getNew((${child.entity})child ,getEntity());
            return;
        }
</#if>
</#list>
        throw new LogicException("${NODEINFO.entity} Entity does not have a child of the requested class (" + child.getClass().getSimpleName() + ")");
    }

    @Override
    protected void _moveReorderChildByFlavor(DataFlavor df, int[] perm) {
<#list NODEINFO.child![] as child>
<#if child.orderable = "yes">
        if (df == ${NODEINFO.name}ChildFactory.${child.name?upper_case}_FLAVOR) {
            getEntity().reorder${child.entity}s(perm, cf.getOffsetMin${child.entity}s(), cf.getOffsetMax${child.entity}s());
            return;
        }
</#if>
</#list>
        throw new LogicException("${NODEINFO.entity} Entity does not have a child of the requested DataFlavor that is reorderable");
    }

    @Override
    protected DataFlavor _getDataFlavor() {
        return null;
    }
}
